---
interface Props {
  /** Path to the .geo.json file (relative to /public) */
  geoSrc: string;
  /** Optional path to the texture PNG (relative to /public) */
  texSrc?: string;
  /** Canvas size in pixels (square). Default: 300 */
  size?: number;
  /** Auto-spin speed multiplier. 0 = static. Default: 1 */
  spinSpeed?: number;
}

const { geoSrc, texSrc, size = 300, spinSpeed = 1 } = Astro.props;
const id = `bmv-${Math.random().toString(36).slice(2, 8)}`;
---

<canvas
  id={id}
  width={size}
  height={size}
  style={`width:${size}px;height:${size}px;display:block;`}
></canvas>

<script
  define:vars={{ id, geoSrc, texSrc, size, spinSpeed }}
  src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
  is:inline
></script>

<script define:vars={{ id, geoSrc, texSrc, size, spinSpeed }}>
(async () => {
  // Poll until THREE is available (script above may still be loading)
  while (typeof THREE === 'undefined') await new Promise(r => setTimeout(r, 20));

  const canvas = document.getElementById(id);

  // ── Renderer ────────────────────────────────────────────────────────────────
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(size, size, false);
  renderer.setClearColor(0x000000, 0); // transparent bg

  const scene  = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 500);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.position.set(20, 40, 30);
  scene.add(key);
  const fill = new THREE.DirectionalLight(0x8888ff, 0.25);
  fill.position.set(-20, -10, -20);
  scene.add(fill);

  // ── Orbit ───────────────────────────────────────────────────────────────────
  let theta = 0, phi = Math.PI / 3.5, radius = 40;
  const target = new THREE.Vector3();

  function updateCamera() {
    camera.position.set(
      target.x + radius * Math.sin(phi) * Math.sin(theta),
      target.y + radius * Math.cos(phi),
      target.z + radius * Math.sin(phi) * Math.cos(theta)
    );
    camera.lookAt(target);
  }

  // Mouse/touch drag
  let dragging = false, lx = 0, ly = 0;
  canvas.addEventListener('mousedown',  e => { dragging = true;  lx = e.clientX; ly = e.clientY; });
  window.addEventListener('mouseup',    ()  => dragging = false);
  window.addEventListener('mousemove',  e  => {
    if (!dragging) return;
    theta -= (e.clientX - lx) * 0.01;
    phi    = Math.max(0.05, Math.min(Math.PI * 0.95, phi + (e.clientY - ly) * 0.01));
    lx = e.clientX; ly = e.clientY;
  });

  let lt = null;
  canvas.addEventListener('touchstart', e => { lt = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }, { passive: true });
  canvas.addEventListener('touchmove',  e => {
    e.preventDefault();
    theta -= (e.touches[0].clientX - lt.x) * 0.012;
    phi    = Math.max(0.05, Math.min(Math.PI * 0.95, phi + (e.touches[0].clientY - lt.y) * 0.012));
    lt = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }, { passive: false });

  // ── Cube builder ─────────────────────────────────────────────────────────────
  // Bedrock box-UV unwrap. flipY=true (CanvasTexture default), so UV.v = 1 - pv/texH.
  function buildBoxMesh(ox, oy, oz, cw, ch, cd, u0, v0, texW, texH, mat) {
    const [x0,x1,y0,y1,z0,z1] = [ox,ox+cw,oy,oy+ch,oz,oz+cd];
    const [w,h,d] = [cw,ch,cd];
    const uv = (pu,pv) => [pu/texW, 1-pv/texH];

    const pos=[], uvs=[], idx=[];
    const face = (verts, fuvs) => {
      const b = pos.length/3;
      verts.forEach(v => pos.push(...v));
      fuvs.forEach(t => uvs.push(...t));
      idx.push(b,b+1,b+2, b,b+2,b+3);
    };

    // North (-Z)
    face([[x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]], [
      uv(u0+d+w,v0+d+h), uv(u0+d,v0+d+h), uv(u0+d,v0+d), uv(u0+d+w,v0+d)]);
    // South (+Z)
    face([[x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]], [
      uv(u0+2*d+2*w,v0+d+h), uv(u0+2*d+w,v0+d+h), uv(u0+2*d+w,v0+d), uv(u0+2*d+2*w,v0+d)]);
    // East (+X)
    face([[x1,y0,z1],[x1,y0,z0],[x1,y1,z0],[x1,y1,z1]], [
      uv(u0+d+w,v0+d+h), uv(u0+2*d+w,v0+d+h), uv(u0+2*d+w,v0+d), uv(u0+d+w,v0+d)]);
    // West (-X)
    face([[x0,y0,z0],[x0,y0,z1],[x0,y1,z1],[x0,y1,z0]], [
      uv(u0,v0+d+h), uv(u0+d,v0+d+h), uv(u0+d,v0+d), uv(u0,v0+d)]);
    // Top (+Y)
    face([[x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]], [
      uv(u0+d,v0+d), uv(u0+d+w,v0+d), uv(u0+d+w,v0), uv(u0+d,v0)]);
    // Bottom (-Y)
    face([[x1,y0,z1],[x0,y0,z1],[x0,y0,z0],[x1,y0,z0]], [
      uv(u0+d+w,v0+d), uv(u0+2*d+w,v0+d), uv(u0+2*d+w,v0), uv(u0+d+w,v0)]);

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs, 2));
    geo.setIndex(idx);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // ── Load geo JSON ─────────────────────────────────────────────────────────────
  const json = await fetch(geoSrc).then(r => r.json());
  const geoDef = json['minecraft:geometry']?.[0];
  if (!geoDef) { console.error('BedrockModelViewer: no minecraft:geometry found'); return; }

  const texW = geoDef.description.texture_width  || 64;
  const texH = geoDef.description.texture_height || 64;

  // Check if any cube uses per-face UV mapping
  let usesPerFaceUV = false;
  for (const bone of (geoDef.bones || [])) {
    for (const cube of (bone.cubes || [])) {
      if (!Array.isArray(cube.uv)) {
        usesPerFaceUV = true;
        break;
      }
    }
    if (usesPerFaceUV) break;
  }

  // If per-face UV and we have a texture, show flat image instead
  if (usesPerFaceUV && texSrc) {
    canvas.style.display = 'none';
    const img = document.createElement('img');
    img.src = texSrc;
    img.style.width = size + 'px';
    img.style.height = size + 'px';
    img.style.imageRendering = 'pixelated';
    canvas.parentNode.insertBefore(img, canvas);
    return; // Stop here, don't load Three.js model
  }

  // ── Load texture (optional) ───────────────────────────────────────────────────
  let mat;
  if (texSrc) {
    const img = await new Promise((res, rej) => {
      const i = new Image();
      i.onload  = () => res(i);
      i.onerror = rej;
      i.src = texSrc;
    });
    const cv = document.createElement('canvas');
    cv.width = img.naturalWidth; cv.height = img.naturalHeight;
    cv.getContext('2d').drawImage(img, 0, 0);
    const tex = new THREE.CanvasTexture(cv);
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    tex.needsUpdate = true;
    mat = new THREE.MeshLambertMaterial({ map: tex, transparent: true, alphaTest: 0.1 });
  } else {
    mat = new THREE.MeshLambertMaterial({ color: 0x4fffb0 });
  }

  // ── Build model ───────────────────────────────────────────────────────────────
  const group = new THREE.Group();
  for (const bone of (geoDef.bones || [])) {
    const [px,py,pz] = bone.pivot || [0,0,0];
    const bg = new THREE.Group();
    bg.position.set(px, py, pz);
    for (const cube of (bone.cubes || [])) {
      if (!Array.isArray(cube.uv)) continue; // per-face UV not needed for basic use
      const [ox,oy,oz] = cube.origin;
      const [cw,ch,cd] = cube.size;
      bg.add(buildBoxMesh(ox-px, oy-py, oz-pz, cw, ch, cd, cube.uv[0], cube.uv[1], texW, texH, mat));
    }
    group.add(bg);
  }

  // Center + fit
  const box = new THREE.Box3().setFromObject(group);
  const ctr = new THREE.Vector3();
  box.getCenter(ctr);
  group.position.sub(ctr);
  const sz = new THREE.Vector3();
  box.getSize(sz);
  radius = Math.max(sz.x, sz.y, sz.z) * 2.4;
  scene.add(group);

  // ── Render loop ───────────────────────────────────────────────────────────────
  const clock = new THREE.Clock();
  (function loop() {
    requestAnimationFrame(loop);
    theta += clock.getDelta() * spinSpeed * 0.8;
    updateCamera();
    renderer.render(scene, camera);
  })();
})();
</script>
