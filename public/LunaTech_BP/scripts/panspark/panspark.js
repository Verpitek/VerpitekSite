function N(){var W="0123456789abcdef",H="",J=0;while(J<36){if(J===8||J===13||J===18||J===23)H+="-";else if(J===14)H+="4";else if(J===19){var Q=Math.floor(Math.random()*4);H+=W[Q+8]}else{var Q=Math.floor(Math.random()*16);H+=W[Q]}J++}return H}var L=(W)=>({type:0,value:W}),F=(W)=>({type:1,value:W}),j=(W)=>({type:2,value:W}),z;(($)=>{$[$.SET=0]="SET";$[$.MATH=1]="MATH";$[$.PRINT=2]="PRINT";$[$.ECHO=3]="ECHO";$[$.POINT=4]="POINT";$[$.JUMP=5]="JUMP";$[$.IF=6]="IF";$[$.END=7]="END";$[$.RETURN=8]="RETURN";$[$.CALL=9]="CALL";$[$.PROC=10]="PROC";$[$.WAIT=11]="WAIT";$[$.INC=12]="INC";$[$.DEC=13]="DEC";$[$.FREE=14]="FREE";$[$.NOP=15]="NOP";$[$.MEMDUMP=16]="MEMDUMP";$[$.MEMSTATS=17]="MEMSTATS";$[$.TICK=18]="TICK";$[$.ENDPROC=19]="ENDPROC";$[$.FOR=20]="FOR";$[$.ENDFOR=21]="ENDFOR";$[$.BREAK=22]="BREAK";$[$.CONTINUE=23]="CONTINUE";$[$.LIST_CREATE=24]="LIST_CREATE";$[$.LIST_SET=25]="LIST_SET";$[$.LIST_GET=26]="LIST_GET";$[$.LIST_PUSH=27]="LIST_PUSH";$[$.LIST_SORT=28]="LIST_SORT";$[$.LIST_LENGTH=29]="LIST_LENGTH";$[$.LIST_REVERSE=30]="LIST_REVERSE";$[$.LIST_FIND=31]="LIST_FIND";$[$.LIST_INDEX_OF=32]="LIST_INDEX_OF";$[$.LIST_CONTAINS=33]="LIST_CONTAINS";$[$.LIST_REMOVE=34]="LIST_REMOVE";$[$.CONCAT=35]="CONCAT";$[$.STRLEN=36]="STRLEN";$[$.SUBSTR=37]="SUBSTR";$[$.STR_UPPER=38]="STR_UPPER";$[$.STR_LOWER=39]="STR_LOWER";$[$.STR_TRIM=40]="STR_TRIM";$[$.STR_REPLACE=41]="STR_REPLACE";$[$.STR_CONTAINS=42]="STR_CONTAINS";$[$.STR_CHAR=43]="STR_CHAR";$[$.TYPEOF=44]="TYPEOF";$[$.TRY=45]="TRY";$[$.CATCH=46]="CATCH";$[$.ENDTRY=47]="ENDTRY";$[$.THROW=48]="THROW"})(z||={});class P{pool=[];allocate(){let W=this.pool.pop();if(W)return W.variableMemory.clear(),W.returnLocation=0,W.returnValueTarget=null,W.procStartLine=0,W.procEndLine=0,W.procName="",W.args=[],W;return{variableMemory:new Map,returnLocation:0,returnValueTarget:null,procStartLine:0,procEndLine:0,procName:"",args:[]}}free(W){this.pool.push(W)}clear(){this.pool=[]}}class y{input;position=0;tokens=[];constructor(W){this.input=W,this.tokenize()}tokenize(){while(this.position<this.input.length){let W=this.input[this.position];if(/\s/.test(W)){this.position++;continue}if(/\d/.test(W)){let Q="";while(this.position<this.input.length&&/[\d.]/.test(this.input[this.position]))Q+=this.input[this.position],this.position++;this.tokens.push({type:"NUMBER",value:Q});continue}if(/[a-zA-Z_]/.test(W)){let Q="";while(this.position<this.input.length&&/[a-zA-Z0-9_]/.test(this.input[this.position]))Q+=this.input[this.position],this.position++;this.tokens.push({type:"IDENT",value:Q});continue}let H=this.input.substr(this.position,2);if(H==="**"||H==="=="||H==="!="||H==="<="||H===">="){this.tokens.push({type:"OP",value:H}),this.position+=2;continue}let J=this.input[this.position];if("+-*/%()".includes(J)){this.tokens.push({type:J==="("?"LPAREN":J===")"?"RPAREN":"OP",value:J}),this.position++;continue}throw Error(`Unexpected character: ${J} at position ${this.position}`)}this.tokens.push({type:"EOF",value:""})}getTokens(){return this.tokens}}class A{tokens;current=0;constructor(W){let H=new y(W);this.tokens=H.getTokens()}parse(){return this.parseExpression()}parseExpression(){return this.parseAdditive()}parseAdditive(){let W=this.parseMultiplicative();while(this.peek().value==="+"||this.peek().value==="-"){let H=this.advance().value,J=this.parseMultiplicative();W={type:"binary",operator:H,left:W,right:J}}return W}parseMultiplicative(){let W=this.parsePower();while(this.peek().value==="*"||this.peek().value==="/"||this.peek().value==="%"){let H=this.advance().value,J=this.parsePower();W={type:"binary",operator:H,left:W,right:J}}return W}parsePower(){let W=this.parseUnary();if(this.peek().value==="**"){let H=this.advance().value,J=this.parsePower();W={type:"binary",operator:H,left:W,right:J}}return W}parseUnary(){if(this.peek().value==="-"||this.peek().value==="+"){let W=this.advance().value,H=this.parseUnary();return{type:"unary",operator:W,operand:H}}return this.parsePrimary()}parsePrimary(){let W=this.peek();if(W.type==="NUMBER")return this.advance(),{type:"number",value:parseFloat(W.value)};if(W.type==="IDENT")return{type:"variable",name:this.advance().value};if(W.type==="LPAREN"){this.advance();let H=this.parseExpression();if(this.peek().type!=="RPAREN")throw Error("Expected ) after expression");return this.advance(),H}throw Error(`Unexpected token: ${W.value} (type: ${W.type})`)}peek(){return this.tokens[this.current]}advance(){return this.tokens[this.current++]}}var M=/"((?:\\.|[^"\\])*)"|\[([^\]]*)\]|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g;function b(W){return W.replace(/\\n/g,`
`).replace(/\\t/g,"\t").replace(/\\r/g,"\r").replace(/\\\\/g,"\x00").replace(/\\"/g,'"').replace(/\x00/g,"\\")}class S{jumpPoints=new Map;procPoints=new Map;variableMemory=new Map;uuid=N();buffer=[];maxVariableCount=null;debugMode=!1;procStack=[];forStack=[];framePool=new P;procReturn=L(0);shouldReturn=!1;tryStack=[];lastError="";waitTicks=0;counter=0;customOpCodes=new Map;importedModules=new Set;binaryMathOps=new Map([["%",(W,H)=>W%H],["**",(W,H)=>Math.pow(W,H)],["min",(W,H)=>Math.min(W,H)],["max",(W,H)=>Math.max(W,H)]]);unaryMathOps=new Map([["sqrt",(W)=>Math.sqrt(W)],["log",(W)=>Math.log(W)],["floor",(W)=>Math.floor(W)],["ceil",(W)=>Math.ceil(W)],["sin",(W)=>Math.sin(W)],["rand",(W)=>Math.random()*W],["cos",(W)=>Math.cos(W)],["tan",(W)=>Math.tan(W)],["abs",(W)=>Math.abs(W)],["round",(W)=>Math.round(W)],["log10",(W)=>Math.log10(W)],["exp",(W)=>Math.exp(W)]]);constructor(){}evaluateExpression(W,H){return this.evaluateExpressionAST(W,H)}evaluateExpressionAST(W,H){try{let Q=new A(W).parse();return this.evaluateASTNode(Q,H)}catch(J){let Q=J instanceof Error?J.message:String(J);throw Error(`Expression evaluation error at line ${H}: ${Q}`)}}evaluateASTNode(W,H){switch(W.type){case"number":return W.value;case"variable":{let J=W,Q=this.variableCheck(J.name,H);if(Q.type!==0)throw Error(`Variable "${J.name}" is not a number`);return Q.value}case"unary":{let J=W,Q=this.evaluateASTNode(J.operand,H);if(J.operator==="-")return-Q;else if(J.operator==="+")return Q;throw Error(`Unknown unary operator: ${J.operator}`)}case"binary":{let J=W,Q=this.evaluateASTNode(J.left,H),Y=this.evaluateASTNode(J.right,H);switch(J.operator){case"+":return Q+Y;case"-":return Q-Y;case"*":return Q*Y;case"/":if(Y===0)throw Error("Division by zero");return Q/Y;case"%":return Q%Y;case"**":return Math.pow(Q,Y);default:throw Error(`Unknown binary operator: ${J.operator}`)}}default:throw Error("Unknown AST node type")}}registerOpCode(W,H){this.customOpCodes.set(W.toUpperCase(),H)}setMaxVariableCount(W){this.maxVariableCount=W}getMaxVariableCount(){return this.maxVariableCount}getVariableCount(){return this.variableMemory.size+(this.procStack.length>0?this.procVariableMemory.size:0)}setDebugMode(W){this.debugMode=W}isDebugMode(){return this.debugMode}getCallStack(){if(this.procStack.length===0)return"Global scope";return`Call stack:
${this.procStack.map((H,J)=>{return`${"  ".repeat(J)}â†’ ${H.procName} (line ${H.procStartLine+1})`}).join(`
`)}`}enhanceErrorMessage(W,H){let J=this.getCallStack();return`${W}
${J}`}get procLock(){return this.procStack.length>0}get procVariableMemory(){if(this.procStack.length===0)return new Map;return this.procStack[this.procStack.length-1].variableMemory}getCurrentProcBoundaries(){if(this.procStack.length===0)return null;let W=this.procStack[this.procStack.length-1];return[W.procStartLine,W.procEndLine]}setVariableMemory(W,H){let J=this.procLock?this.procVariableMemory:this.variableMemory;if(this.maxVariableCount!==null&&!J.has(W)){let Q=this.variableMemory.size+this.procVariableMemory.size;if(Q>=this.maxVariableCount)throw Error(`Variable limit exceeded: Cannot create variable "${W}". Maximum ${this.maxVariableCount} variables allowed (currently have ${Q}). Use FREE to remove unused variables or increase the limit with setMaxVariableCount().`)}J.set(W,H)}variableCheck(W,H){if(this.procLock){let Y=this.procVariableMemory.get(W);if(Y!==void 0)return Y}let J=this.variableMemory.get(W);if(J!==void 0)return J;let Q=Number(W);if(!isNaN(Q))return{type:0,value:Q};throw Error(`Variable "${W}" is not defined at line ${H}`)}variableOrStringLiteral(W,H){if(this.procLock){let Y=this.procVariableMemory.get(W);if(Y!==void 0)return Y}let J=this.variableMemory.get(W);if(J!==void 0)return J;let Q=Number(W);if(!isNaN(Q))return{type:0,value:Q};return{type:1,value:W}}jumpPointCheck(W,H){let J=this.jumpPoints.get(W);if(J===void 0)throw Error(`Jump point "${W}" is not defined at line ${H}.`);return J}safeJumpPointCheck(W,H){let J=this.jumpPointCheck(W,H);if(this.procLock){let Q=this.getCurrentProcBoundaries();if(Q){let[Y,Z]=Q;if(J<Y||J>Z){let G=this.procStack[this.procStack.length-1];throw Error(`Cannot jump to "${W}" at line ${H}: Jump target is outside procedure "${G.procName}" scope (procedure spans lines ${Y+1}-${Z+1})`)}}}return J}procPointCheck(W,H){let J=this.procPoints.get(W);if(J===void 0)throw Error(`Proc "${W}" is not defined at line ${H}.`);return J}compile(W){let H=W.split(`
`),J=[];this.jumpPoints.clear(),this.procPoints.clear();let Q=0,Y=0;for(let U=0;U<H.length;U++){let q=H[U].trim(),R=q.indexOf("//");if(R!==-1)q=q.substring(0,R).trim();if(q==="")continue;M.lastIndex=0;let X=[],_;while((_=M.exec(q))!==null)if(_[1]!==void 0)X.push(b(_[1]));else if(_[2]!==void 0)X.push(`${_[2]}`);else if(_[3]!==void 0)X.push(">>",_[3]);else if(_[4]!==void 0)X.push(_[4]);else if(_[5]!==void 0)X.push(_[5]);if(X.length===0)continue;let E=X[0].toUpperCase(),B=z[X[0].toUpperCase()];if(B===void 0&&this.customOpCodes.has(E))B=E;if(B===void 0)B=E;let D={operation:B,args:X.slice(1),line:U+1};if(typeof B==="string"&&this.customOpCodes.has(B))D.customHandler=this.customOpCodes.get(B);if(B===20)Q++;else if(B===21){if(Q--,Q<0)throw Error(`Unexpected ENDFOR at line ${U+1} without matching FOR`)}if(B===45)Y++;else if(B===47){if(Y--,Y<0)throw Error(`Unexpected ENDTRY at line ${U+1} without matching TRY`)}J.push(D)}let Z={name:"",startLine:0,endLine:0},G=!1,K=[];for(let U=0;U<J.length;U++){let q=J[U];if(q.operation===4)this.jumpPoints.set(q.args[0],U);if(!G){if(q.operation===10)Z={name:q.args[0],startLine:U,endLine:0},G=!0}if(q.operation===19){if(!G)throw Error(`Unexpected '}' at line ${q.line} without matching PROC`);Z.endLine=U,this.procPoints.set(Z.name,[Z.startLine,Z.endLine]),G=!1}if(q.operation===45)K.push({startLine:U,catchIndex:null,errorVar:q.args[0]||null});else if(q.operation===46){if(K.length===0)throw Error(`Unexpected CATCH at line ${q.line} without matching TRY`);K[K.length-1].catchIndex=U}else if(q.operation===47){if(K.length===0)throw Error(`Unexpected ENDTRY at line ${q.line} without matching TRY`);K.pop()}}if(G)throw Error(`Unclosed PROC "${Z.name}" starting at line ${Z.startLine+1}`);if(K.length>0)throw Error(`Unclosed TRY block starting at line ${K[0].startLine+1}`);for(let U=0;U<J.length;U++){let q=J[U];if(q.operation===5&&q.args.length>0){let R=this.jumpPoints.get(q.args[0]);if(R===void 0)throw Error(`Jump target "${q.args[0]}" not found at line ${q.line}. Valid targets are: ${Array.from(this.jumpPoints.keys()).join(", ")||"(none defined)"}`);q.jumpTarget=R}else if(q.operation===6){let R="",X=">>",_=q.args.indexOf(X);if(_!==-1&&_<q.args.length-1)R=q.args[q.args.length-1];else if(q.args.length>=5&&!["AND","OR"].includes(q.args[3]))R=q.args[4];else if(q.args.length>=9)R=q.args[q.args.length-1];if(R){let E=this.jumpPoints.get(R);if(E===void 0)throw Error(`Jump target "${R}" not found at line ${q.line}. Valid targets are: ${Array.from(this.jumpPoints.keys()).join(", ")||"(none defined)"}`);q.jumpTarget=E}if(R){let E=this.jumpPoints.get(R);if(E===void 0)throw Error(`Jump target "${R}" not found at line ${q.line}. Valid targets are: ${Array.from(this.jumpPoints.keys()).join(", ")||"(none defined)"}`);q.jumpTarget=E}}else if(q.operation===20){let R=-1,X=0;for(let _=U+1;_<J.length;_++){if(J[_].operation===20)X++;if(J[_].operation===21){if(X===0){R=_;break}X--}}if(R===-1)throw Error(`FOR loop at line ${q.line} has no matching ENDFOR`);q.endForIndex=R}}return J}executeMath(W,H,J){switch(J){case"+":return W+H;case"-":return W-H;case"*":return W*H;case"/":{if(H===0)throw Error(`Division by zero error: cannot divide ${W} by 0`);return W/H}default:{let Q=this.binaryMathOps.get(J);if(Q)return Q(W,H);throw Error(`Unknown binary operator: ${J}`)}}}executeUnaryMath(W,H){let J=this.unaryMathOps.get(H);if(J)return J(W);throw Error(`Unknown unary operator: ${H}`)}shouldBatchExecute(W,H){let J=0,Q=Math.min(50,W.length-H);for(let Y=0;Y<Q;Y++){let Z=W[H+Y];if(Z.operation===11||Z.operation===5||Z.operation===6||Z.operation===9||Z.operation===8||Z.operation===7)break;J++}return J}*run(W){this.counter=0;H:while(this.counter<W.length){if(yield this.counter,this.waitTicks>0){this.waitTicks--;break}let H=W[this.counter];if(this.debugMode){let J=typeof H.operation==="string"?H.operation:z[H.operation],Q=H.args.length>0?` [${H.args.slice(0,3).join(", ")}${H.args.length>3?", ...":""}]`:"";this.buffer.push(`[DEBUG] Line ${H.line}: ${J}${Q} (tick: ${this.counter})`)}if(this.shouldReturn&&this.procLock){let J=this.getCurrentProcBoundaries();if(J){this.counter=J[1],this.shouldReturn=!1;continue}}if(typeof H.operation==="string"){let J=H.customHandler||this.customOpCodes.get(H.operation);if(J){let Q={buffer:this.buffer,variableMemory:this.variableMemory,procVariableMemory:this.procVariableMemory,procLock:this.procLock,getVar:(Y,Z)=>this.variableCheck(Y,Z),setVar:(Y,Z)=>this.setVariableMemory(Y,Z)};J(H.args,Q)}else throw Error(`Unknown opcode '${H.operation}' at line ${H.line}. Make sure the required module is imported.`)}else try{switch(H.operation){case 0:{if(H.args.length===1)if(isNaN(Number(H.args[0])))this.setVariableMemory(H.args[0],L(0));else throw Error(`Invalid variable name '${H.args[0]}' at line ${H.line}`);else{let J=H.args[0],Q;if(J==="")Q=F("");else if(!isNaN(Number(J)))Q=L(Number(J));else try{Q=this.variableCheck(J,H.line)}catch{Q=F(J)}this.setVariableMemory(H.args[2],Q)}break}case 12:{let J=this.variableCheck(H.args[0],H.line);if(J.type!==0)throw Error(`The provided variable is not a number at line ${H.line}`);this.setVariableMemory(H.args[0],L(J.value+1));break}case 13:{let J=this.variableCheck(H.args[0],H.line);if(J.type!==0)throw Error(`The provided variable is not a number at line ${H.line}`);this.setVariableMemory(H.args[0],L(J.value-1));break}case 24:{let J=[];this.setVariableMemory(H.args[0],j(J));break}case 27:{let J=this.variableCheck(H.args[2],H.line),Q=this.variableCheck(H.args[0],H.line);if(J.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Q.type!==0)throw Error(`The provided value is not a number at line ${H.line}`);J.value.push(Q.value),this.setVariableMemory(H.args[2],J);break}case 26:{let J=this.variableCheck(H.args[0],H.line),Q=this.variableCheck(H.args[1],H.line);if(J.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Q.type!==0)throw Error(`The provided index is not a number at line ${H.line}`);let Y=J.value[Q.value];if(Y===void 0)throw Error(`The provided index is out of bounds at line ${H.line}`);this.setVariableMemory(H.args[3],L(Y));break}case 25:{let J=this.variableCheck(H.args[3],H.line),Q=this.variableCheck(H.args[1],H.line),Y=this.variableCheck(H.args[0],H.line);if(Q.type!==0)throw Error(`The provided index is not a number at line ${H.line}`);if(Y.type!==0)throw Error(`The provided value is not a number at line ${H.line}`);if(J.type!==2)throw Error(`The provided list is not a list at line ${H.line}`);if(Q.value<0||Q.value>=J.value.length)throw Error(`List index ${Q.value} out of bounds at line ${H.line}. List has ${J.value.length} elements (valid indices: 0-${J.value.length-1})`);J.value[Q.value]=Y.value,this.setVariableMemory(H.args[3],J);break}case 28:{let J=this.variableCheck(H.args[0],H.line);if(J.type!==2)throw Error(`The provided list is not a list at line ${H.line}`);if(H.args[1]==="min")J.value.sort((Q,Y)=>Q-Y);else if(H.args[1]==="max")J.value.sort((Q,Y)=>Y-Q);else throw Error(`Invalid sort order at line ${H.line}`);break}case 29:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid LIST_LENGTH syntax at line ${H.line}. Expected: LIST_LENGTH list >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);this.setVariableMemory(Y,L(Q.value.length));break}case 30:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid LIST_REVERSE syntax at line ${H.line}. Expected: LIST_REVERSE list >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);let Z=[...Q.value].reverse();this.setVariableMemory(Y,j(Z));break}case 31:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid LIST_FIND syntax at line ${H.line}. Expected: LIST_FIND list value >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Y.type!==0)throw Error(`The search value must be a number at line ${H.line}`);let G=Q.value.indexOf(Y.value);this.setVariableMemory(Z,L(G));break}case 32:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid LIST_INDEX_OF syntax at line ${H.line}. Expected: LIST_INDEX_OF list value >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Y.type!==0)throw Error(`The search value must be a number at line ${H.line}`);let G=Q.value.indexOf(Y.value);this.setVariableMemory(Z,L(G));break}case 33:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid LIST_CONTAINS syntax at line ${H.line}. Expected: LIST_CONTAINS list value >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Y.type!==0)throw Error(`The search value must be a number at line ${H.line}`);let G=Q.value.includes(Y.value)?1:0;this.setVariableMemory(Z,L(G));break}case 34:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid LIST_REMOVE syntax at line ${H.line}. Expected: LIST_REMOVE list index >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1];if(Q.type!==2)throw Error(`The provided variable is not a list at line ${H.line}`);if(Y.type!==0)throw Error(`The index must be a number at line ${H.line}`);if(Y.value<0||Y.value>=Q.value.length)throw Error(`Index ${Y.value} out of bounds at line ${H.line}`);let G=Q.value.splice(Y.value,1)[0];this.setVariableMemory(Z,L(G));break}case 35:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid CONCAT syntax at line ${H.line}. Expected: CONCAT string1 string2 >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1],G="",K="";if(Q.type===1)G=Q.value;else if(Q.type===0)G=Q.value.toString();else throw Error(`Cannot concatenate list at line ${H.line}`);if(Y.type===1)K=Y.value;else if(Y.type===0)K=Y.value.toString();else throw Error(`Cannot concatenate list at line ${H.line}`);let U=G+K;this.setVariableMemory(Z,F(U));break}case 36:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid STRLEN syntax at line ${H.line}. Expected: STRLEN string >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1],Z=0;if(Q.type===1)Z=Q.value.length;else if(Q.type===0)Z=Q.value.toString().length;else throw Error(`Cannot get length of list at line ${H.line}`);this.setVariableMemory(Y,L(Z));break}case 37:{let J=H.args.indexOf(">>");if(J===-1||J<3||J===H.args.length-1)throw Error(`Invalid SUBSTR syntax at line ${H.line}. Expected: SUBSTR string start end >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=this.variableCheck(H.args[2],H.line),G=H.args[J+1];if(Y.type!==0||Z.type!==0)throw Error(`SUBSTR indices must be numbers at line ${H.line}`);let K="";if(Q.type===1)K=Q.value;else if(Q.type===0)K=Q.value.toString();else throw Error(`Cannot substring a list at line ${H.line}`);let U=K.substring(Y.value,Z.value);this.setVariableMemory(G,F(U));break}case 38:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid STR_UPPER syntax at line ${H.line}. Expected: STR_UPPER string >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1],Z="";if(Q.type===1)Z=Q.value;else if(Q.type===0)Z=Q.value.toString();else throw Error(`Cannot uppercase a list at line ${H.line}`);this.setVariableMemory(Y,F(Z.toUpperCase()));break}case 39:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid STR_LOWER syntax at line ${H.line}. Expected: STR_LOWER string >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1],Z="";if(Q.type===1)Z=Q.value;else if(Q.type===0)Z=Q.value.toString();else throw Error(`Cannot lowercase a list at line ${H.line}`);this.setVariableMemory(Y,F(Z.toLowerCase()));break}case 40:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid STR_TRIM syntax at line ${H.line}. Expected: STR_TRIM string >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=H.args[J+1],Z="";if(Q.type===1)Z=Q.value;else if(Q.type===0)Z=Q.value.toString();else throw Error(`Cannot trim a list at line ${H.line}`);this.setVariableMemory(Y,F(Z.trim()));break}case 41:{let J=H.args.indexOf(">>");if(J===-1||J<3||J===H.args.length-1)throw Error(`Invalid STR_REPLACE syntax at line ${H.line}. Expected: STR_REPLACE string find replace >> result`);let Q=this.variableOrStringLiteral(H.args[0],H.line),Y=this.variableOrStringLiteral(H.args[1],H.line),Z=this.variableOrStringLiteral(H.args[2],H.line),G=H.args[J+1],K="";if(Q.type===1)K=Q.value;else if(Q.type===0)K=Q.value.toString();else throw Error(`Cannot replace in a list at line ${H.line}`);let U="";if(Y.type===1)U=Y.value;else if(Y.type===0)U=Y.value.toString();else throw Error(`Find pattern cannot be a list at line ${H.line}`);let q="";if(Z.type===1)q=Z.value;else if(Z.type===0)q=Z.value.toString();else throw Error(`Replace value cannot be a list at line ${H.line}`);let R=K.replace(new RegExp(U,"g"),q);this.setVariableMemory(G,F(R));break}case 42:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid STR_CONTAINS syntax at line ${H.line}. Expected: STR_CONTAINS string substring >> result`);let Q=this.variableOrStringLiteral(H.args[0],H.line),Y=this.variableOrStringLiteral(H.args[1],H.line),Z=H.args[J+1],G="";if(Q.type===1)G=Q.value;else if(Q.type===0)G=Q.value.toString();else throw Error(`Cannot search in a list at line ${H.line}`);let K="";if(Y.type===1)K=Y.value;else if(Y.type===0)K=Y.value.toString();else throw Error(`Search pattern cannot be a list at line ${H.line}`);let U=G.includes(K)?1:0;this.setVariableMemory(Z,L(U));break}case 43:{let J=H.args.indexOf(">>");if(J===-1||J<2||J===H.args.length-1)throw Error(`Invalid STR_CHAR syntax at line ${H.line}. Expected: STR_CHAR string index >> result`);let Q=this.variableCheck(H.args[0],H.line),Y=this.variableCheck(H.args[1],H.line),Z=H.args[J+1];if(Y.type!==0)throw Error(`STR_CHAR index must be a number at line ${H.line}`);let G="";if(Q.type===1)G=Q.value;else if(Q.type===0)G=Q.value.toString();else throw Error(`Cannot get character from a list at line ${H.line}`);let K=G.charAt(Y.value);this.setVariableMemory(Z,F(K));break}case 14:{if(this.procLock)this.procVariableMemory.delete(H.args[0]);else this.variableMemory.delete(H.args[0]);break}case 16:{if(this.buffer.push(`DUMPING MEMORY at line ${H.line}`),this.procLock)if(this.buffer.push(`  [PROC "${this.procStack[this.procStack.length-1].procName}" LOCAL MEMORY - Depth: ${this.procStack.length}]`),this.procVariableMemory.size===0)this.buffer.push("    (empty)");else for(let[J,Q]of this.procVariableMemory.entries())this.buffer.push(`    ${J}: ${Q.value}`);if(this.buffer.push("  [GLOBAL MEMORY]"),this.variableMemory.size===0)this.buffer.push("    (empty)");else for(let[J,Q]of this.variableMemory.entries())this.buffer.push(`    ${J}: ${Q.value}`);this.buffer.push("END OF MEMORY DUMP");break}case 17:{let J=this.variableMemory.size,Q=this.procLock?this.procVariableMemory.size:0,Y=0;for(let[q,R]of this.variableMemory.entries())if(Y+=q.length,R.type===0)Y+=8;else if(R.type===1)Y+=R.value.length;else if(R.type===2)Y+=R.value.length*8;let Z=0;if(this.procLock){for(let[q,R]of this.procVariableMemory.entries())if(Z+=q.length,R.type===0)Z+=8;else if(R.type===1)Z+=R.value.length;else if(R.type===2)Z+=R.value.length*8}let G=this.procLock?this.procStack.length:0,K=H.args.indexOf(">>"),U=null;if(K!==-1&&K<H.args.length-1)U=H.args[K+1];if(U){let q=`STATS:GlobalVars=${J},LocalVars=${Q},GlobalMem=${Y}B,LocalMem=${Z}B,ProcDepth=${G}`;this.setVariableMemory(U,F(q))}else{if(this.buffer.push("=== MEMORY STATISTICS ==="),this.buffer.push(`Global Variables: ${J}`),this.buffer.push(`Local Variables: ${Q}`),this.buffer.push(`Global Memory: ~${Y} bytes`),this.buffer.push(`Local Memory: ~${Z} bytes`),this.buffer.push(`Procedure Depth: ${G}`),this.maxVariableCount>0){let q=this.maxVariableCount-J-Q;this.buffer.push(`Variable Limit: ${this.maxVariableCount} (${q} remaining)`)}this.buffer.push(`Total Ticks: ${this.counter}`)}break}case 15:break;case 18:{this.setVariableMemory(H.args[0],L(this.counter));break}case 2:{let J=this.variableCheck(H.args[0],H.line);if(J.type===0)this.buffer.push(J.value.toString());else if(J.type===1)this.buffer.push(J.value);else if(J.type===2)this.buffer.push("["+J.value.toString()+"]");break}case 3:{this.buffer.push(H.args[0].toString());break}case 44:{let J=H.args.indexOf(">>");if(J===-1||J===0||J===H.args.length-1)throw Error(`Invalid TYPEOF syntax at line ${H.line}. Expected: TYPEOF variable >> result`);let Q=H.args[0],Y=H.args[J+1];try{let Z=this.variableCheck(Q,H.line),G="";switch(Z.type){case 0:G="number";break;case 1:G="string";break;case 2:G="list";break}this.setVariableMemory(Y,F(G))}catch(Z){this.setVariableMemory(Y,F("undefined"))}break}case 1:{let{args:J,line:Q}=H,Y=J.indexOf(">>");if(Y===-1||Y===J.length-1)throw Error(`Invalid MATH syntax at line ${Q}. Expected: MATH expression >> result`);let Z=J[Y+1],G=J.slice(0,Y);if(G.length===2){let q=G[1];if(this.unaryMathOps.has(q)){let R=this.variableCheck(G[0],Q);if(R.type!==0)throw Error(`The provided variable is not a number at line ${Q}`);let X=this.executeUnaryMath(R.value,q);this.setVariableMemory(Z,L(X));break}}if(G.length===3){let q=G[1];if(["+","-","*","/","%","**","min","max"].includes(q)){let R=G[0];if(!R.includes(" ")&&!R.includes("(")&&!R.includes(")")&&!R.startsWith("-")&&!R.startsWith("+")){let X=this.variableCheck(R,Q),_=this.variableCheck(G[2],Q);if(X.type!==0||_.type!==0)throw Error(`The provided variables are not numbers at line ${Q}`);let E=this.executeMath(X.value,_.value,q);this.setVariableMemory(Z,L(E));break}}}let K=G.map((q)=>{if(typeof q==="string"){if(["+","-","*","/","%","**","min","max"].includes(q))return q;if(!isNaN(Number(q))||q.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/))return q;if(q.startsWith("(")&&q.endsWith(")"))return q;if((q.startsWith("-")||q.startsWith("+"))&&q.includes("("))return q;if(q.includes(" ")||q.match(/[+\-*/%]/))return`(${q})`}return q}).join(" "),U=this.evaluateExpression(K,Q);if(Number.isNaN(U))throw Error(`Math operation resulted in NaN at line ${Q}`);this.setVariableMemory(Z,L(U));break}case 6:{let J=H.args,Q=!1;if(J.length>=5&&!["AND","OR","NOT"].includes(J[1])){let Y=this.variableCheck(J[0],H.line),Z=this.variableCheck(J[2],H.line),G,K;if(Y.type===0)G=Y.value;else throw Error(`Cannot compare non-numeric value at line ${H.line}`);if(Z.type===0)K=Z.value;else throw Error(`Cannot compare non-numeric value at line ${H.line}`);switch(J[1]){case">":Q=G>K;break;case"<":Q=G<K;break;case"==":Q=G==K;break;case"!=":Q=G!=K;break;case">=":Q=G>=K;break;case"<=":Q=G<=K;break;default:throw Error(`Invalid comparison operator "${J[1]}" at line ${H.line}`)}}else if(J[0]==="NOT"){let Y=J[1];try{let Z=this.variableCheck(Y,H.line);if(Z.type===0)Q=Z.value===0;else throw Error(`NOT requires a numeric value at line ${H.line}`)}catch{Q=!0}}else if(J.length>=7){let Y=!1,Z=!1,G=J[3];if(G==="AND"||G==="OR"){let K=this.variableCheck(J[0],H.line),U=J[1],q=this.variableCheck(J[2],H.line);if(K.type!==0||q.type!==0)throw Error(`Comparison values must be numbers at line ${H.line}`);let R=K.value,X=q.value;switch(U){case">":Y=R>X;break;case"<":Y=R<X;break;case"==":Y=R==X;break;case"!=":Y=R!=X;break;case">=":Y=R>=X;break;case"<=":Y=R<=X;break;default:throw Error(`Invalid comparison operator "${U}" at line ${H.line}`)}let _=this.variableCheck(J[4],H.line),E=J[5],B=this.variableCheck(J[6],H.line);if(_.type!==0||B.type!==0)throw Error(`Comparison values must be numbers at line ${H.line}`);let D=_.value,T=B.value;switch(E){case">":Z=D>T;break;case"<":Z=D<T;break;case"==":Z=D==T;break;case"!=":Z=D!=T;break;case">=":Z=D>=T;break;case"<=":Z=D<=T;break;default:throw Error(`Invalid comparison operator "${E}" at line ${H.line}`)}if(G==="AND")Q=Y&&Z;else Q=Y||Z}else throw Error(`Invalid IF syntax at line ${H.line}`)}else throw Error(`Invalid IF syntax at line ${H.line}`);if(Q){let Y=J[J.length-1];if(H.jumpTarget!==void 0)this.counter=H.jumpTarget-1;else this.counter=this.safeJumpPointCheck(Y,H.line)-1}break}case 7:break H;case 5:{if(H.jumpTarget!==void 0)this.counter=H.jumpTarget-1;else{let J=this.safeJumpPointCheck(H.args[0],H.line);this.counter=J-1}break}case 8:{if(this.procLock){if(H.args.length>0)this.procReturn=this.variableCheck(H.args[0],H.line);else this.procReturn=L(0);this.shouldReturn=!0}else throw Error(`RETURN can only be used inside a procedure at line ${H.line}`);break}case 4:break;case 10:{let J=H.args;if(!this.procLock){let Q=this.procPointCheck(J[0],this.counter);this.counter=Q[1]-1}else{let Q=J[1]||"",Y=Q.trim()===""?[]:Q.split(",").map((K)=>K.trim()),Z=this.procStack[this.procStack.length-1],G=Z.args;if(G.length!==Y.length)throw Error(`Procedure "${Z.procName}" expects ${Y.length} arguments but received ${G.length} at line ${H.line}`);for(let K=0;K<Y.length;K++)this.procVariableMemory.set(Y[K],G[K])}break}case 19:{if(this.procLock){let J=this.procStack.pop();if(J.returnValueTarget)this.variableMemory.set(J.returnValueTarget,this.procReturn);this.procReturn=L(0),this.shouldReturn=!1,this.framePool.free(J),this.counter=J.returnLocation}break}case 20:{let J=H.args;if(J.length<3)throw Error(`Invalid FOR syntax at line ${H.line}. Expected: FOR variable start end [step]`);let Q=J[0],Y=this.variableCheck(J[1],H.line),Z=this.variableCheck(J[2],H.line),G=1;if(J.length>=4){let U=this.variableCheck(J[3],H.line);if(U.type!==0)throw Error(`FOR loop step must be a number at line ${H.line}`);if(G=U.value,G===0)throw Error(`FOR loop step cannot be zero at line ${H.line}`)}if(Y.type!==0||Z.type!==0)throw Error(`FOR loop bounds must be numbers at line ${H.line}`);if(G>0&&Z.value<Y.value)throw Error(`Invalid FOR loop at line ${H.line}. With positive step, end value must be >= start value`);if(G<0&&Z.value>Y.value)throw Error(`Invalid FOR loop at line ${H.line}. With negative step, end value must be <= start value`);let K=H.endForIndex;if(K===void 0)throw Error(`FOR loop at line ${H.line} has no matching ENDFOR (compilation error)`);this.setVariableMemory(Q,L(Y.value)),this.forStack.push({varName:Q,endValue:Z.value,forStartLine:this.counter,endForLine:K,step:G});break}case 21:{if(this.forStack.length===0)throw Error(`ENDFOR without matching FOR at line ${H.line}`);let J=this.forStack[this.forStack.length-1],Q=this.variableCheck(J.varName,H.line);if(Q.type!==0)throw Error(`Loop variable must be a number at line ${H.line}`);let Y=Q.value+J.step;if(J.step>0?Y<=J.endValue:Y>=J.endValue)this.setVariableMemory(J.varName,L(Y)),this.counter=J.forStartLine;else this.forStack.pop();break}case 22:{if(this.forStack.length===0)throw Error(`BREAK can only be used inside a FOR loop at line ${H.line}`);let J=this.forStack.pop();this.counter=J.endForLine;break}case 23:{if(this.forStack.length===0)throw Error(`CONTINUE can only be used inside a FOR loop at line ${H.line}`);let J=this.forStack[this.forStack.length-1],Q=this.variableCheck(J.varName,H.line);if(Q.type!==0)throw Error(`Loop variable must be a number at line ${H.line}`);let Y=Q.value+1;if(Y<=J.endValue)this.setVariableMemory(J.varName,L(Y)),this.counter=J.forStartLine;else this.forStack.pop(),this.counter=J.endForLine;break}case 9:{let J=H.args;if(J.length<2)throw Error(`Invalid CALL syntax at line ${H.line}. Expected: CALL procName (args) or CALL procName (args) >> result`);let Q=J[0],Y=this.procPointCheck(Q,H.line),Z=null;if(J.length>2&&J[2]===">>"&&J[3])Z=J[3];let G=J[1]||"",K=G.trim()===""?[]:G.split(",").map((R)=>R.trim()),U=[];for(let R of K)if(R!=="")U.push(this.variableCheck(R,H.line));let q=this.framePool.allocate();q.returnLocation=this.counter,q.returnValueTarget=Z,q.procStartLine=Y[0],q.procEndLine=Y[1],q.procName=Q,q.args=U,this.procStack.push(q),this.counter=Y[0]-1;break}case 11:{let J=H.args;if(J[0]){let Q=this.variableCheck(J[0],H.line);if(Q.type===0)this.waitTicks=Math.floor(Q.value);else throw Error(`WAIT requires a numeric value at line ${H.line}`)}break}case 45:{let J=H.args[0]||"_error",Q=-1,Y=0;for(let G=this.counter+1;G<W.length;G++){if(W[G].operation===45)Y++;if(W[G].operation===46&&Y===0){Q=G;break}if(W[G].operation===47&&Y===0)break;if(W[G].operation===47)Y--}if(Q===-1)throw Error(`TRY without CATCH at line ${H.line}`);let Z=-1;Y=0;for(let G=this.counter+1;G<W.length;G++){if(W[G].operation===45)Y++;if(W[G].operation===47&&Y===0){Z=G;break}if(W[G].operation===47)Y--}if(Z===-1)throw Error(`TRY without ENDTRY at line ${H.line}`);this.tryStack.push({startLine:this.counter,catchLine:Q,endLine:Z,errorVariable:J,errorOccurred:!1});break}case 46:{if(this.tryStack.length>0&&!this.tryStack[this.tryStack.length-1].errorOccurred){let J=this.tryStack[this.tryStack.length-1];this.counter=J.endLine}break}case 47:{if(this.tryStack.length>0)this.tryStack.pop();break}case 48:{let J=H.args[0]||"An error occurred";if(this.lastError=J,this.tryStack.length>0){let Q=this.tryStack[this.tryStack.length-1];this.setVariableMemory(Q.errorVariable,F(J)),Q.errorOccurred=!0,this.counter=Q.catchLine-1}else throw Error(`THROW: ${J}`);break}default:throw Error(`Unknown operation ${H.operation} at line ${H.line}`)}}catch(J){if(this.tryStack.length>0){let Q=this.tryStack[this.tryStack.length-1],Y=J instanceof Error?J.message:String(J);this.buffer.push(Y),this.setVariableMemory(Q.errorVariable,F(Y)),Q.errorOccurred=!0,this.counter=Q.catchLine-1}else throw J}this.counter++}return 0}resetVM(){this.variableMemory.clear(),this.jumpPoints.clear(),this.procPoints.clear(),this.buffer=[],this.forStack=[],this.procStack=[],this.forStack=[],this.framePool.clear(),this.procReturn=L(0),this.shouldReturn=!1,this.waitTicks=0,this.counter=0,this.importedModules.clear(),this.tryStack=[],this.lastError=""}getBuffer(){return this.buffer}getVariableMemory(){return this.variableMemory}loadModule(W,H){if(this.importedModules.has(W))return;if(H&&typeof H.registerWith==="function")H.registerWith(this),this.importedModules.add(W);else throw Error(`Module '${W}' does not export a registerWith function`)}saveState(W){let H={uuid:this.uuid,counter:this.counter,waitTicks:this.waitTicks,variableMemory:this.serializeVariableMap(this.variableMemory),jumpPoints:Array.from(this.jumpPoints.entries()),procPoints:Array.from(this.procPoints.entries()),procStack:this.procStack.map((Y)=>({variableMemory:this.serializeVariableMap(Y.variableMemory),returnLocation:Y.returnLocation,returnValueTarget:Y.returnValueTarget,procStartLine:Y.procStartLine,procEndLine:Y.procEndLine,procName:Y.procName,args:Y.args.map((Z)=>this.serializeVariable(Z))})),forStack:this.forStack,tryStack:this.tryStack,lastError:this.lastError,procReturn:this.serializeVariable(this.procReturn),shouldReturn:this.shouldReturn,buffer:this.buffer,maxVariableCount:this.maxVariableCount,debugMode:this.debugMode,instructions:W?W.map((Y)=>({operation:Y.operation,args:Y.args,line:Y.line,jumpTarget:Y.jumpTarget,endForIndex:Y.endForIndex})):null},J=JSON.stringify(H),Q=32767;if(J.length>32767)throw Error(`State size (${J.length} characters) exceeds maximum limit of 32767 characters. Clear the output buffer, reduce variables, or use multiple checkpoints.`);return J}loadState(W){try{if(W.length>32767)throw Error(`Serialized state (${W.length} characters) exceeds maximum limit of 32767 characters`);let H=JSON.parse(W);if(this.uuid=H.uuid,this.counter=H.counter,this.waitTicks=H.waitTicks,this.variableMemory=this.deserializeVariableMap(H.variableMemory),this.jumpPoints=new Map(H.jumpPoints),this.procPoints=new Map(H.procPoints),this.procStack=H.procStack.map((J)=>({variableMemory:this.deserializeVariableMap(J.variableMemory),returnLocation:J.returnLocation,returnValueTarget:J.returnValueTarget,procStartLine:J.procStartLine,procEndLine:J.procEndLine,procName:J.procName,args:J.args.map((Q)=>this.deserializeVariable(Q))})),this.forStack=H.forStack,this.tryStack=H.tryStack||[],this.lastError=H.lastError||"",this.procReturn=this.deserializeVariable(H.procReturn),this.shouldReturn=H.shouldReturn,this.buffer=H.buffer,this.maxVariableCount=H.maxVariableCount,this.debugMode=H.debugMode,H.instructions)return H.instructions;return null}catch(H){let J=H instanceof Error?H.message:String(H);throw Error(`Failed to load VM state: ${J}`)}}serializeVariable(W){return{type:W.type,value:W.value}}deserializeVariable(W){switch(W.type){case 0:return L(W.value);case 1:return F(W.value);case 2:return j(W.value);default:throw Error(`Unknown variable type: ${W.type}`)}}serializeVariableMap(W){return Array.from(W.entries()).map(([H,J])=>[H,this.serializeVariable(J)])}deserializeVariableMap(W){let H=new Map;for(let[J,Q]of W)H.set(J,this.deserializeVariable(Q));return H}}function k(){return new S}export{k as createVM,F as Str,S as PanSparkVM,L as Num,j as List};
