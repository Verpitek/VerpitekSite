function Q(f, M) { let y = M.arguments[0], V = M.arguments[1]; f.setMemory(y.value, V) } function B(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(f.fetchMemory(y) + f.fetchMemory(V), m) } function G(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(f.fetchMemory(y) - f.fetchMemory(V), m) } function U(f, M) { let y = M.arguments[0]; if (y.type == 0) f.outputBuffer.push(y.value); if (y.type == 1) f.outputBuffer.push(f.fetchMemory(y)); if (y.type == 2) f.outputBuffer.push(f.fetchMemory(y)) } function k(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2], h; switch (V.type) { case 3: h = f.fetchMemory(y) == f.fetchMemory(m); break; case 4: h = f.fetchMemory(y) != f.fetchMemory(m); break; case 5: h = f.fetchMemory(y) < f.fetchMemory(m); break; case 6: h = f.fetchMemory(y) > f.fetchMemory(m); break; case 7: h = f.fetchMemory(y) <= f.fetchMemory(m); break; case 8: h = f.fetchMemory(y) >= f.fetchMemory(m); break; default: h = !1 }return h } function L(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(f.fetchMemory(y) * f.fetchMemory(V), m) } function q(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(f.fetchMemory(y) / f.fetchMemory(V), m) } function w(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(f.fetchMemory(y) % f.fetchMemory(V), m) } function N(f, M) { let y = M.arguments[0], V = M.arguments[1]; f.setMemory(Math.sqrt(f.fetchMemory(y)), V) } function S(f, M) { let y = M.arguments[0], V = M.arguments[1], m = M.arguments[2]; f.setMemory(Math.pow(f.fetchMemory(y), f.fetchMemory(V)), m) } function Y(f, M) { let y = M.arguments[0], V = M.arguments[1]; f.setMemory(Math.abs(f.fetchMemory(y)), V) } function j(f, M) { let y = M.arguments[0], V = f.fetchMemory(y), m = M.arguments[1], h = f.fetchMemory(m), E = M.arguments[2]; if (V < h) f.setMemory(V, E); else f.setMemory(h, E) } function H(f, M) { let y = M.arguments[0], V = f.fetchMemory(y), m = M.arguments[1], h = f.fetchMemory(m), E = M.arguments[2]; if (V > h) f.setMemory(V, E); else f.setMemory(h, E) } function K(f, M) { let y = M.arguments[0], V = f.fetchMemory(y); f.setMemory(V + 1, y) } function W(f, M) { let y = M.arguments[0], V = f.fetchMemory(y); f.setMemory(V - 1, y) } function X(f, M) { let y = f.fetchMemory(M.arguments[0]), V = f.fetchMemory(M.arguments[1]), m = M.arguments[2], h = Math.min(y, V), E = Math.max(y, V), Z = Math.floor(Math.random() * (E - h + 1)) + h; f.setMemory(Z, m) } var _; ((x) => { x[x.SET = 0] = "SET"; x[x.ADD = 1] = "ADD"; x[x.SUB = 2] = "SUB"; x[x.PRINT = 3] = "PRINT"; x[x.JUMP = 4] = "JUMP"; x[x.POINT = 5] = "POINT"; x[x.IF = 6] = "IF"; x[x.MUL = 7] = "MUL"; x[x.DIV = 8] = "DIV"; x[x.MOD = 9] = "MOD"; x[x.SQRT = 10] = "SQRT"; x[x.POW = 11] = "POW"; x[x.ABS = 12] = "ABS"; x[x.MIN = 13] = "MIN"; x[x.MAX = 14] = "MAX"; x[x.INC = 15] = "INC"; x[x.DEC = 16] = "DEC"; x[x.RNG = 17] = "RNG"; x[x.NOP = 18] = "NOP"; x[x.HALT = 19] = "HALT"; x[x.UNTIL = 20] = "UNTIL"; x[x.CALL = 21] = "CALL"; x[x.RET = 22] = "RET" })(_ ||= {}); var R; ((D) => { D[D.LITERAL = 0] = "LITERAL"; D[D.REGISTER = 1] = "REGISTER"; D[D.MEMORY = 2] = "MEMORY"; D[D.EQUAL = 3] = "EQUAL"; D[D.NOTEQUAL = 4] = "NOTEQUAL"; D[D.LESS = 5] = "LESS"; D[D.GREATER = 6] = "GREATER"; D[D.LESSEQUAL = 7] = "LESSEQUAL"; D[D.GREATEQUAL = 8] = "GREATEQUAL"; D[D.LABEL = 9] = "LABEL"; D[D.HEAP = 10] = "HEAP" })(R ||= {}); function $(f) { if (f.startsWith("r")) return { type: 1, value: parseInt(f.slice(1)) }; else if (f.startsWith("x")) return { type: 2, value: parseInt(f.slice(1)) }; else if (f == "==") return { type: 3, value: 0 }; else if (f == "!=") return { type: 4, value: 0 }; else if (f == "<") return { type: 5, value: 0 }; else if (f == ">") return { type: 6, value: 0 }; else if (f == "<=") return { type: 7, value: 0 }; else if (f == ">=") return { type: 8, value: 0 }; else return { type: 0, value: parseInt(f) } } function c(f, M, y) { let V = M.split(" ").splice(1), m = []; for (let h of V) if (h != ">>") m.push($(h)); return { operation: f, arguments: m, line: y } } class F {
    outputBuffer = []; instructions = []; callStack = []; activeInstructionPos = 0; registerMemoryLimit = 0; machineMemoryLimit = 0; callStackLimit = 0; registerMemory = []; machineMemory = []; runFastFlag = !1; constructor(f, M, y) { this.registerMemoryLimit = f, this.machineMemoryLimit = M, this.callStackLimit = y, this.registerMemory = Array(this.registerMemoryLimit).fill(0), this.machineMemory = Array(this.machineMemoryLimit).fill(0) } saveState() { let f = this.activeInstructionPos.toString(), M = this.registerMemory.slice(0, this.findLastNonZeroIndex(this.registerMemory) + 1).join(","), y = this.machineMemory.slice(0, this.findLastNonZeroIndex(this.machineMemory) + 1).join(","), V = this.callStack.join(","), m = this.outputBuffer.join(","), h = JSON.stringify(this.instructions); return `${f}|${M}|${y}|${V}|${m}|${h}` } loadState(f) { let M = 0, y = 0; for (let h = 0; h < f.length && M < 5; h++)if (f[h] === "|") { if (M++, M === 5) { y = h; break } } let V = f.substring(0, y).split("|"), m = f.substring(y + 1); if (V.length < 4) throw Error("Invalid savestate format"); if (this.activeInstructionPos = parseInt(V[0]), this.registerMemory = [], V[1]) { let h = V[1].split(",").map((E) => parseInt(E)); for (let E = 0; E < h.length; E++)this.registerMemory[E] = h[E] } for (let h = this.registerMemory.length; h < this.registerMemoryLimit; h++)this.registerMemory[h] = 0; if (this.machineMemory = [], V[2]) { let h = V[2].split(",").map((E) => parseInt(E)); for (let E = 0; E < h.length; E++)this.machineMemory[E] = h[E] } for (let h = this.machineMemory.length; h < this.machineMemoryLimit; h++)this.machineMemory[h] = 0; if (this.callStack = [], V[3]) { let h = V[3].split(",").map((E) => parseInt(E)); for (let E = 0; E < h.length; E++)this.callStack[E] = h[E] } if (this.outputBuffer = [], V[4]) this.outputBuffer = V[4].split(",").map((h) => parseInt(h)); if (m) this.instructions = JSON.parse(m) } findLastNonZeroIndex(f) { for (let M = f.length - 1; M >= 0; M--)if (f[M] !== 0 && f[M] !== void 0) return M; return -1 } setMemory(f, M) { if (M.type == 0) throw Error("memory destination cannot be a LITERAL! at line: " + (this.activeInstructionPos + 1)); else if (M.type == 1) { if (M.value >= this.registerMemoryLimit || M.value < 0) throw Error("outside register memory bounds!"); this.registerMemory[M.value] = f } else if (M.type == 2) { if (M.value >= this.machineMemoryLimit || M.value < 0) throw Error("outside machine memory bounds!"); this.machineMemory[M.value] = f } else throw Error("illegal operation! at line: " + (this.activeInstructionPos + 1)) } fetchMemory(f) { if (f.type == 0) return f.value; else if (f.type == 1) { if (f.value >= this.registerMemoryLimit || f.value < 0) throw Error("outside register memory bounds!"); return this.registerMemory[f.value] } else if (f.type == 2) { if (f.value >= this.machineMemoryLimit || f.value < 0) throw Error("outside machine memory bounds!"); return this.machineMemory[f.value] } else throw Error("empty or illegal memory fetch! at line: " + (this.activeInstructionPos + 1)) } pushCallStack(f) { if (this.callStack.length >= this.callStackLimit) throw Error("Stack overflow! Too many nested calls."); this.callStack.push(f) } popCallStack() { if (this.callStack.length === 0) throw Error("Stack underflow!"); return this.callStack.pop() } *compile(f) {
        let M = f.split(`
`), y = []; for (let m in M) { M[m] = M[m].trimStart(); let h = M[m].split(" ")[0]; if (h == "" || h.startsWith("//")) continue; else y.push(M[m]) } M = y; let V = new Map; for (let m in M) { let h = M[m].split(" "); if (h[0] == "POINT") V[h[1]] = m } for (let m in M) { let h = null, E = M[m].split(" ")[0]; switch (E) { case "SET": h = c(0, M[m], parseInt(m)); break; case "ADD": h = c(1, M[m], parseInt(m)); break; case "SUB": h = c(2, M[m], parseInt(m)); break; case "PRINT": h = c(3, M[m], parseInt(m)); break; case "JUMP": h = c(4, M[m].replace(M[m].split(" ")[1], V[M[m].split(" ")[1]]), parseInt(m)); break; case "POINT": h = c(5, M[m].replace(M[m].split(" ")[1], V[M[m].split(" ")[1]]), parseInt(m)); break; case "IF": h = c(6, M[m].replace(M[m].split(" ")[5], V[M[m].split(" ")[5]]), parseInt(m)); break; case "MUL": h = c(7, M[m], parseInt(m)); break; case "DIV": h = c(8, M[m], parseInt(m)); break; case "MOD": h = c(9, M[m], parseInt(m)); break; case "SQRT": h = c(10, M[m], parseInt(m)); break; case "POW": h = c(11, M[m], parseInt(m)); break; case "ABS": h = c(12, M[m], parseInt(m)); break; case "MIN": h = c(13, M[m], parseInt(m)); break; case "MAX": h = c(14, M[m], parseInt(m)); break; case "INC": h = c(15, M[m], parseInt(m)); break; case "DEC": h = c(16, M[m], parseInt(m)); break; case "RNG": h = c(17, M[m], parseInt(m)); break; case "NOP": h = c(18, M[m], parseInt(m)); break; case "HALT": h = c(19, M[m], parseInt(m)); break; case "UNTIL": h = c(20, M[m], parseInt(m)); break; case "CALL": h = c(21, M[m].replace(M[m].split(" ")[1], V[M[m].split(" ")[1]]), parseInt(m)); break; case "RET": h = c(22, M[m], parseInt(m)); break; default: console.log("unknown OpCode: " + E); continue }this.instructions.push(h), yield h }
    } *run() { while (this.activeInstructionPos < this.instructions.length) { let f = !1; this.outputBuffer = []; let M = this.instructions[this.activeInstructionPos]; switch (M.operation) { case 0: Q(this, M); break; case 3: U(this, M); break; case 1: B(this, M); break; case 2: G(this, M); break; case 4: this.activeInstructionPos = M.arguments[0].value, f = !0; break; case 5: break; case 6: if (k(this, M) == !0) this.activeInstructionPos = M.arguments[3].value, f = !0; break; case 19: return; case 18: break; case 7: L(this, M); break; case 8: q(this, M); break; case 9: w(this, M); break; case 10: N(this, M); break; case 11: S(this, M); break; case 12: Y(this, M); break; case 13: j(this, M); break; case 14: H(this, M); break; case 15: K(this, M); break; case 16: W(this, M); break; case 17: X(this, M); break; case 20: if (k(this, M) != !0) f = !0; break; case 21: this.pushCallStack(this.activeInstructionPos + 1), this.activeInstructionPos = M.arguments[0].value, f = !0; break; case 22: this.activeInstructionPos = this.popCallStack(), f = !0; break; default: throw Error("Unknown OpCode: " + M.operation) }if (!this.runFastFlag) yield; if (!f) this.activeInstructionPos++ } }
} export { F as VM, _ as OpCode, R as ArgType };
